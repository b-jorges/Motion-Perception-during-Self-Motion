1.3*6.6
0.7*6.6
0.7*6.6*0.5
0.7*6.6*0.7
timeseries = seq(0,0.5,0.01)
pnorm(timeseries, mean = 0.25, sd = 0.08)
dnorm(timeseries, mean = 0.25, sd = 0.08)
plot(timeseries,pnorm(timeseries, mean = 0.25, sd = 0.08))
plot(timeseries,dnorm(timeseries, mean = 0.25, sd = 0.08))
plot(timeseries,pnorm(timeseries, mean = 0.25, sd = 0.08))
rmarkdown::render_site()
plot(cars)
package.report0 = as.matrix(installed.packages())  #all packages installed
package.report1=package.report0[,c(1,3,16)]             #relevant columns
write.table(package.report1, "clipboard", sep="\t", row.names=FALSE)  #copies to clipboard
cat("\n\n\nHEY!, the list is in your clipboard already; go to your browser and just paste it in the survey")
rep(1,5)
rep(c(1,2),5)
rep(c(1,2),each=5)
nVillages = 25
nQuestionnaires = 15
PointInTime = c(1,2)
Test = c(0,1)
PointInTime = c(1,2)
PointInTime
length(PointInTime)
nQuestionnaires*length(PointInTime)
Village <- rep(1:nVillages*length(Test), each=nQuestionnaires*length(PointInTime)) #Vector with village IDs///Electrified = 0 = davor//Electrified = 1 = danach
Village
Village <- rep(1:(nVillages*length(Test)), each=nQuestionnaires*length(PointInTime)) #Vector with village IDs///Electrified = 0 = davor//Electrified = 1 = danach
1:(nVillages*length(Test))
Village <- rep(1:(nVillages*length(Test)), each=nQuestionnaires*length(PointInTime)) #Vector with village IDs///Electrified = 0 = davor//Electrified = 1 = danach
Village
nQuestionnaires = 15
length(PointInTime)
Fix1 <- rep(PointInTime[1], nVillages*nQuestionnaires*length(Test)) #Vector with IDs for first fixed effect
Fix1
nVillages*nQuestionnaires*length(Test)
1:(nVillages*nQuestionnaires*length(Test))
1:3
1:(nVillages*nQuestionnaires*length(Test))
rnorm(5,mean=0,sd = 1)
DataFrame3 = data.frame(x = seq(-0.5,0.5,0.01),
y = rnorm(100,0,0.1))
DataFrame3 = data.frame(x = seq(-0.5,0.5,0.01),
y = rnorm(101,0,0.1))
ggplot(DataFrame3, aes(x)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(0.5,1.5))
library(lme4)
library(dplyr)
library(ggplot2)
DataFrame3 = data.frame(x = seq(-0.5,0.5,0.01),
y = rnorm(101,0,0.1))
ggplot(DataFrame3, aes(x)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-0.5,0.5))
DataFrame3 = data.frame(x = seq(-0.5,0.5,0.01),
y = rnorm(101,0,0.1))
ggplot(DataFrame3, aes(x)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-1,1))
DataFrame3 = data.frame(x = seq(-1,1,0.01),
y = rnorm(201,0,0.1))
ggplot(DataFrame3, aes(x)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-1,1))
DataFrame3 = data.frame(x = seq(-1,1,0.01),
y = rnorm(201,0,0.01))
ggplot(DataFrame3, aes(x)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-1,1))
DataFrame3 = data.frame(x = seq(-1,1,0.01),
y = rnorm(201,0,0.1))
ggplot(DataFrame3, aes(x)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-1,1))
DataFrame3 = data.frame(x = seq(-1,1,0.01),
y = dnorm(201,0,0.1))
ggplot(DataFrame3, aes(x)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-1,1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-1,1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density()
DataFrame3 = data.frame(x = rcauchy(1000,1,0.05),
y = rnorm(1000,1,0.1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(0.5,1.5))
DataFrame3 = data.frame(x = rcauchy(1000,1,0.05),
y = rnorm(1000,1,0.1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(0.5,1.5))
DataFrame3 = data.frame(y = rnorm(1000,1,0.1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(0.5,1.5))
DataFrame3 = data.frame(y = rnorm(1000,1,0.1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(0.5,1.5))
DataFrame3 = data.frame(y = rnorm(1000,0,0.1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(0.5,1.5))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density()
DataFrame3 = data.frame(y = rnorm(1000,0,0.1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-0.5,1.5))
DataFrame3 = data.frame(y = abs(rnorm(1000,0,0.1)))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-0.5,1.5))
DataFrame3 = data.frame(y = abs(rnorm(1000,0,0.5)))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(-0.5,1.5))
DifferenceTime1Time2*(Fix1==unique(PointInTime)[1])
Fix1==unique(PointInTime)[1])
EffectElectrification
S.re[Village]
# income variability per village
S.re <- abs(rnorm(nVillages*nQuestionnaires*length(Test)*length(PointInTime), mean=0, sd=sdVillages))
sdVillages = 0.1
# income variability per village
S.re <- abs(rnorm(nVillages*nQuestionnaires*length(Test)*length(PointInTime), mean=0, sd=sdVillages))
sdSubjects = 0.1
#inter-subject error that is not correlated with effect
eps <- abs(rnorm(nVillages*nQuestionnaires*length(Test), mean = 0, sd = sdSubjects))
# put it all together
Income <- Intercept + DifferenceTime1Time2*(Fix1==unique(PointInTime)[1]) +
DifferenceControlTest*(Fix2==unique(Test)[1]) +
EffectElectrification*(Fix1==unique(PointInTime)[1])*(Fix2==unique(Test)[1]) +
S.re[Village] + eps
Intercept = 1
# put it all together
Income <- Intercept + DifferenceTime1Time2*(Fix1==unique(PointInTime)[1]) +
DifferenceControlTest*(Fix2==unique(Test)[1]) +
EffectElectrification*(Fix1==unique(PointInTime)[1])*(Fix2==unique(Test)[1]) +
S.re[Village] + eps
View(DataFrame3)
DataFrame3 = data.frame(x = rcauchy(1000,1,0.05),
y = rnorm(1000,1,0.1))
ggplot(DataFrame3, aes(y)) + ####just to get an idea of what this function looks like
geom_density() +
coord_cartesian(xlim=c(0.5,1.5))
View(DataFrame3)
?lmer
?lmer
DifferenceTime1Time2 = 0 #expected difference between time 1 and time 2 in control group (in absence of electrification ... 0 = income remains equal on average)
PointInTime = c(1,2)
DifferenceControlTest = 0 #expected difference between control and test group at point in time 1
Test = c(0,1)
EffectElectrification = 0.05 #how much do we expect the income to increase due to electrification? 0.1 = 10%
Intercept = 1 #baseline income (1 for 100%)
sdVillages = 0.2 #income distribution across villages
sdSubjects = 0.7 #income distribution across people
nVillages = 20 #villages per group (e. g. 20 in test group and 20 in control group)
VariabilityInTime = 0.1 #how variable is income from survey one to survey two
Power_Question1
#######################transform physical speeds into observer centric speeds (= radial velocity)
TimeSeries = seq(0,0.5,0.01)
vx = c(-8,-6.6,6.6,8)
ObserverMotion = c(-0.25,0,0.25)
Conversion = expand.grid(TimeSeries,vx,ObserverMotion)
colnames(Conversion) = c("TimeSeries", "vx", "ObserverMotion")
Conversion = Conversion %>%
mutate(ObserverInSpace = case_when(
ObserverMotion == 0 ~ 0,
ObserverMotion == 0.25 ~ -0.5 + pnorm(TimeSeries,abs(ObserverMotion),0.08)*2,
ObserverMotion == -0.25 ~ 0.5 -pnorm(TimeSeries,abs(ObserverMotion),0.08)*2),
TargetInSpace = -(- ObserverMotion*4 + vx * 0.5)/2 + vx*TimeSeries,
Distance = ((ObserverInSpace-TargetInSpace)^2 + 8^2)^0.5,
Angle = RadiansToDegree(atan((ObserverInSpace-TargetInSpace)/8)),
AngleVelocity = abs(Angle - lag(Angle, n = 1))/0.01) %>%
#  filter(AngleVelocity < 100 & AngleVelocity > 0 ) %>%
mutate(Congruent = case_when(
ObserverMotion*vx == 0 ~ "Static",
ObserverMotion*vx < 0 ~ "Incongruent",
ObserverMotion*vx > 0 ~ "Congruent")
)
ggplot(Conversion, aes(TimeSeries,Distance,col = as.factor(Congruent))) +
geom_point(size=3)
Where_Am_I <- function(path=T){
if (path == T){
dirname(rstudioapi::getSourceEditorContext()$path)
}
else {
rstudioapi::getSourceEditorContext()$path
}
}
binomial_smooth <- function(...) {
geom_smooth(method = "glm", method.args = list(family = "binomial"), ...)}
setwd(Where_Am_I())
source("Utilities/parabolic.r")
#######################transform physical speeds into observer centric speeds (= radial velocity)
TimeSeries = seq(0,0.5,0.01)
vx = c(-8,-6.6,6.6,8)
ObserverMotion = c(-0.25,0,0.25)
Conversion = expand.grid(TimeSeries,vx,ObserverMotion)
colnames(Conversion) = c("TimeSeries", "vx", "ObserverMotion")
Conversion = Conversion %>%
mutate(ObserverInSpace = case_when(
ObserverMotion == 0 ~ 0,
ObserverMotion == 0.25 ~ -0.5 + pnorm(TimeSeries,abs(ObserverMotion),0.08)*2,
ObserverMotion == -0.25 ~ 0.5 -pnorm(TimeSeries,abs(ObserverMotion),0.08)*2),
TargetInSpace = -(- ObserverMotion*4 + vx * 0.5)/2 + vx*TimeSeries,
Distance = ((ObserverInSpace-TargetInSpace)^2 + 8^2)^0.5,
Angle = RadiansToDegree(atan((ObserverInSpace-TargetInSpace)/8)),
AngleVelocity = abs(Angle - lag(Angle, n = 1))/0.01) %>%
#  filter(AngleVelocity < 100 & AngleVelocity > 0 ) %>%
mutate(Congruent = case_when(
ObserverMotion*vx == 0 ~ "Static",
ObserverMotion*vx < 0 ~ "Incongruent",
ObserverMotion*vx > 0 ~ "Congruent")
)
ggplot(Conversion, aes(TimeSeries,Distance,col = as.factor(Congruent))) +
geom_point(size=3)
